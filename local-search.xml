<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ceshi</title>
    <link href="/2024/06/20/ceshi/"/>
    <url>/2024/06/20/ceshi/</url>
    
    <content type="html"><![CDATA[<p>1231123</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ceshi</title>
    <link href="/2024/06/20/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/"/>
    <url>/2024/06/20/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1-ComponentScan"><a href="#1-ComponentScan" class="headerlink" title="1. @ComponentScan"></a>1. @ComponentScan</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.shangan&quot;&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p><code>@ComponentScan</code> 注解用于指定 Spring 应用程序上下文在初始化时应该扫描的包，以查找和注册 Spring 组件（如 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等注解标记的类）。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><strong>包扫描</strong>：扫描 <code>com.shangan</code> 包及其子包中的所有类，寻找标记了 Spring 组件注解的类，并将它们注册到 Spring 应用上下文中。</li><li><strong>自动装配</strong>：通过自动装配（Autowiring）机制，可以在应用程序的其他部分（如 Service 层、Controller 层等）中自动注入这些组件。</li></ul><h3 id="2-MapperScan"><a href="#2-MapperScan" class="headerlink" title="2. @MapperScan"></a>2. @MapperScan</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&#123;&quot;com.shangan.trade.coupon.db.mappers&quot;&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h4><p><code>@MapperScan</code> 注解用于指定 MyBatis 应该扫描的包，以查找和注册 MyBatis 的 Mapper 接口。</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul><li><strong>Mapper 扫描</strong>：扫描 <code>com.shangan.trade.coupon.db.mappers</code> 包及其子包中的所有接口，寻找标记了 <code>@Mapper</code> 注解的接口，并将它们注册为 MyBatis Mapper。</li><li><strong>生成代理对象</strong>：MyBatis 会为这些 Mapper 接口生成代理对象，这些对象可以直接在应用程序中调用，以执行数据库操作。</li></ul><h4 id="MapperScan-识别和注入的机制"><a href="#MapperScan-识别和注入的机制" class="headerlink" title="@MapperScan 识别和注入的机制"></a><code>@MapperScan</code> 识别和注入的机制</h4><ol><li><strong>启动时扫描</strong>：Spring Boot 启动时，<code>@MapperScan</code> 会触发包扫描机制，扫描指定包路径下的所有接口。</li><li><strong>符合条件的接口</strong>：这些接口如果符合 MyBatis Mapper 的规范（即符合方法签名），就会被认为是 Mapper 接口。</li><li><strong>生成代理对象</strong>：MyBatis 会为这些接口生成代理对象，这些代理对象会被注册为 Spring Bean。</li><li><strong>自动注入</strong>：Spring 会将这些代理对象作为 Spring Bean 注入到需要使用它们的地方（例如 Service 类中）。</li></ol><p>即使没有使用 <code>@Mapper</code> 注解，只要你使用了 <code>@MapperScan</code> 注解并指定了正确的包路径，MyBatis 仍然能够识别这些接口为 Mapper 接口，并将它们注册为 Spring Bean。这是因为 <code>@MapperScan</code> 注解本质上是通过包扫描机制和 MyBatis 的内部实现来完成这一任务的。</p><p>通过这种方式，你可以简化配置，并确保所有符合条件的 Mapper 接口都能被自动扫描和注入到 Spring 容器中。</p><h3 id="3-MyBatis逆向开发工具生成mapper"><a href="#3-MyBatis逆向开发工具生成mapper" class="headerlink" title="3.MyBatis逆向开发工具生成mapper"></a>3.MyBatis逆向开发工具生成mapper</h3><h3 id="4-threadlocal"><a href="#4-threadlocal" class="headerlink" title="4.threadlocal"></a>4.threadlocal</h3><ul><li>每个线程有一个独立的 <code>ThreadLocalMap</code>。</li><li>需要存储不同类型的值时，就创建不同的 <code>ThreadLocal</code> 实例（每个实例代表一个不同的键）。</li><li>这些 <code>ThreadLocal</code> 实例不直接存储数据，而是作为键存在于 <code>ThreadLocalMap</code> 中，每个键对应一个值的存储位置。</li><li>通过 <code>ThreadLocal</code> 实例访问数据时，实际上是在操作 <code>ThreadLocalMap</code> 中对应的条目。</li></ul><p>这种机制确保了每个线程的数据隔离，即使多个线程使用相同的 <code>ThreadLocal</code> 类型，它们也不会共享数据，因为每个线程都有自己的 <code>ThreadLocalMap</code> 实例。</p><h3 id="5-AllArgsConstructor"><a href="#5-AllArgsConstructor" class="headerlink" title="5@AllArgsConstructor"></a>5@AllArgsConstructor</h3><p>给所有参数都加上构造函数</p><p>@RequiredArgsConstructor&#x2F;&#x2F;对必须的成员变量初始化，给加final的成员变量生成构造函数。初始化过的也不会被初始化</p><h3 id="6-远程调用"><a href="#6-远程调用" class="headerlink" title="6.远程调用"></a>6.远程调用</h3><p>discoveryclient拉取实例列表；</p><p>进行负载均衡，选取实例；</p><p>得到uri；</p><p>restTemplate来发送http请求，获得其他服务查询后的指定结果。</p><p>OpenFeign：</p><p>加依赖（OpenFeign和loadBalancer的）；启动类注解@EnableFeignClients；新建Client接口来声明查询的函数。</p><p>在接口中（接口不用实现，由openfeign自动实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span><span class="comment">//声明服务名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span><span class="comment">//借用mvc注解，表面这是http的get请求。</span></span><br><span class="line">    <span class="comment">//请求路径：/items</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">    <span class="comment">//List&lt;ItemDTO&gt;声明返回参数，openfeign会将收到的json转为该格式</span></span><br><span class="line">    <span class="comment">//@RequestParam(&quot;ids&quot;)声明请求参数，即路径中有ids</span></span><br><span class="line">    <span class="comment">//Collection&lt;Long&gt; ids传入的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样OpenFeign便替代原来discoveryclient和restTemplate的作用，来首先向注册中心请求实例列表，然后负载均衡选择实例，然后发送http请求，然后将收到信息转化为对应形式，这样便完成了微服务之间数据的调用。</p><p>实际使用只需注入ItemClient，然后使用queryItemByIds即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(itemIds);</span><br></pre></td></tr></table></figure><h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><p>减少创建连接销毁连接带来的损耗。</p><p>默认feign发http请求不带连接池，所以可以换成okhttp来提升响应速度。</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>新建一个api模块，存放所有模块要暴露的接口。</p><p>这样别的模块依赖ta便具有了这些接口。</p><p>注意：启动类上要加@EnableFeignClients(basePackages &#x3D; “com.hmall.api.client”)</p><p>指定扫描包去扫描feign客户端，这样才可以扫描到，才能去使用</p><p>jwt的库要加进去</p><p>nacos要打开</p><p>运行要选择local sql</p><h3 id="7-网关的登录校验思路"><a href="#7-网关的登录校验思路" class="headerlink" title="7.网关的登录校验思路"></a>7.网关的登录校验思路</h3><p><img   src="https://md-picture-fangyiming.oss-cn-beijing.aliyuncs.com/typora/imd/202406111858991.png"  alt="image-20240609122541465"></p><p>handlemapping实现是基于路由断言来做匹配的，基于配置的断言与前端请求匹配，找到合适的路由，然后存入上下文</p><p>1.如何在网关自定义过滤器并控制顺序；<br>2.如何在网关中进行登录校验<br>3.如何把网关的用户信息传递给微服务（使用网关api进行）<br>4.如何在微服务之间传递用户信息（使用feign进行）</p><p>网关中有很多过滤器（默认的与需配置的），过滤器生效与不生效是不一定的，filteringwebhandler作用在于找到生效的过滤器，进行排序，并依次执行</p><p>filteringwebhandler最后是nettyroutingfilter，这个过滤器是最后的过滤器，其把请求转到微服务中，当返回结果时，会封装结果，存入上下文，依次返回给其他过滤器。</p><p>过滤器内部有pre和post两个部分，请求会先执行过滤器中的pre部分，若失败，则直接结束，请求也不会被转发，只有pre逻辑执行成功情况下，才会调用执行下一个pre逻辑，依次向下执行，</p><p>因此要通过网关实现登录校验，需要自定义过滤器实现校验逻辑，并且需要在nettyroutingfilter之前的pre部分进行，这样才可以在校验失败时，报错。从而不会转发。</p><p>如何把网关得到的用户信息传递给微服务：由于使用http发，因此可以在请求头中写用户信息来传递。传统的threadlocal不可以，因为是微服务，单个服务用一个tomcat服务器，threadlocal只能在tomcat内部的线程之间共享，因此无法使用threadlocal来共享。</p><h3 id="8-ConfigurationProperties注解报错"><a href="#8-ConfigurationProperties注解报错" class="headerlink" title="8.ConfigurationProperties注解报错"></a>8.ConfigurationProperties注解报错</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span></span><br></pre></td></tr></table></figure><p>Not registered via @EnableConfigurationProperties, marked as Spring component, or scanned via @ConfigurationPropertiesScan</p><h3 id="9-nginx"><a href="#9-nginx" class="headerlink" title="9.nginx"></a>9.nginx</h3><p>使用nginx，因此前端都是通过18080端口访问nginx服务器，这样来访问网关以及服务。</p><h3 id="10-gateway与mvc"><a href="#10-gateway与mvc" class="headerlink" title="10.gateway与mvc"></a>10.gateway与mvc</h3><p>网关用的不是springmvc的架构，他是非阻塞的结构，因此无法用mvc里的元素</p><h3 id="11-匿名内部类"><a href="#11-匿名内部类" class="headerlink" title="11.匿名内部类"></a>11.匿名内部类</h3><p>使用匿名内部类可以有效地实现两步：</p><p>1.创建一个类，该类继承或实现接口</p><p>2.创建一个对象</p><p>&#x3D;&#x3D;因此在希望使用一个类，但只希望使用其创建一次对象时，就可以使用匿名内部类&#x3D;&#x3D;</p><h3 id="12-Feign"><a href="#12-Feign" class="headerlink" title="12.Feign"></a>12.Feign</h3><p>Feign在编写http请求时，要与controller完全一致</p><h3 id="13-微服务中登录验证与信息传递的拦截器"><a href="#13-微服务中登录验证与信息传递的拦截器" class="headerlink" title="13.微服务中登录验证与信息传递的拦截器"></a>13.微服务中登录验证与信息传递的拦截器</h3><p>登录验证：</p><p>网关中过滤器实现。校验token，得到用户信息。有效才路由，无效则返回。</p><p>信息传递：</p><p>1）网关到微服务：</p><p>过滤器将用户信息保存到请求头，然后发送至微服务，微服务使用mvc拦截器获取用户信息，并存入threadlocal（微服务均在一个线程上，因此可以用threadlocal存储）来方便调用。</p><p>2）微服务间远程调用：</p><p>微服务的远程调用也需要用户信息，即被调用的程序执行操作需要进一步的用户信息，由于用户信息经由拦截器存储，因此需要在使用openfeign发送http请求时在请求头中加入用户信息。</p><p>加入用户信息可以采用feign的拦截器，其会在每次feign调用时都处理，因此可以在其中加入填写请求头的操作。</p><p>tips：</p><p>1）mvc拦截器在common中写，因此所有都会继承，但网关使用的不是mvc架构，因此会报错。这就需要</p><p>@ConditionalOnClass(DispatcherServlet.class)来判断该模块是否为微服务，是的话才会加载mvc配置类，才会加入拦截器。</p><p>2）拦截器有pre和after部分，pre是存用户信息，after是删除。需注意pre要先判断用户信息是否为空（用户登陆时不会拦截，因此用户信息可能为空，拦截器也需要考虑这种情况）。</p><p>3）mvc配置类写完后，还需要自动注入</p><p>Spring Boot 的自动配置机制是会扫描所有父类的spring.factories，然后加载里面的所有配置类</p><p><img   src="https://md-picture-fangyiming.oss-cn-beijing.aliyuncs.com/typora/imd/202406131257165.png"  alt="image-20240613125737034"></p><p>微服务内部同一个线程来回调，所以保存到threadlocal来保存用户信息。</p><p>微服务调用spring mvc拦截器来拦截请求。</p><p>feign拦截器会在每一次请求时生效。</p><p>采用匿名内部类生成拦截器对象更方便，不用重新写一个类+生成对象了。</p><h3 id="14-javaBean"><a href="#14-javaBean" class="headerlink" title="14.javaBean"></a>14.javaBean</h3><p>在 Java 编程中，”Java Bean” 是一个具有特定特征的 Java 对象。虽然所有 Java Bean 都是 Java 对象，但并不是所有 Java 对象都是 Java Bean。Java Bean 遵循一些特定的约定，使其在许多框架（如 Spring）中易于使用。</p><h5 id="Java-Bean-的特征"><a href="#Java-Bean-的特征" class="headerlink" title="Java Bean 的特征"></a>Java Bean 的特征</h5><ol><li><strong>私有属性（Private Fields）</strong>：<ul><li>Java Bean 使用私有字段来存储其属性。</li></ul></li><li><strong>公有的无参构造函数（Public No-Arg Constructor）</strong>：<ul><li>Java Bean 必须有一个公有的无参构造函数。这允许框架和工具通过反射机制创建 Bean 实例。</li></ul></li><li><strong>Getter 和 Setter 方法</strong>：<ul><li>Java Bean 提供公有的 getter 和 setter 方法用于访问和修改属性。getter 和 setter 方法遵循命名约定：<code>getXxx</code> 和 <code>setXxx</code>（对于布尔类型的属性，getter 方法可以使用 <code>isXxx</code>）。</li></ul></li></ol><h3 id="15-什么是-Spring-Bean"><a href="#15-什么是-Spring-Bean" class="headerlink" title="15.什么是 Spring Bean"></a>15.什么是 Spring Bean</h3><ul><li><strong>定义</strong>：Spring Bean 是由 Spring 容器管理的对象。Spring 容器负责生命周期管理、依赖注入以及与 Spring 上下文的交互。</li><li><strong>注册方式</strong>：Spring Bean 可以通过多种方式注册到 Spring 容器中，包括注解和 XML 配置。</li><li><strong>作用</strong>：Spring Bean 可以用于任何需要被 Spring 容器管理的对象，包括服务、数据访问对象、控制器、配置类等。</li></ul><h4 id="声明-Spring-Bean-的方式"><a href="#声明-Spring-Bean-的方式" class="headerlink" title="声明 Spring Bean 的方式"></a>声明 Spring Bean 的方式</h4><ol><li><p><strong>使用 <code>@Component</code> 注解</strong>：</p><ul><li><p><code>@Component</code> 注解是一个通用的注解，表示一个组件类。它是一个元注解，可以用于标记任何要作为 Spring Bean 管理的类。</p></li><li><p>派生注解</p><p>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br></pre></td></tr></table></figure><p> 还有几个特定用途的派生注解：</p><ul><li><code>@Service</code>：表示服务层组件。</li><li><code>@Repository</code>：表示数据访问层组件，具有数据访问层的特定功能，如异常转换。</li><li><code>@Controller</code>：表示 Spring MVC 控制器。</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyComponent</span> &#123;</span><br><span class="line">    <span class="comment">// 组件逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="comment">// 服务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRepository</span> &#123;</span><br><span class="line">    <span class="comment">// 数据访问逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="comment">// 控制器逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>@Configuration</code> 和 <code>@Bean</code> 注解</strong>：</p><ul><li><code>@Configuration</code> 注解表示一个配置类，该类可以包含一个或多个 <code>@Bean</code> 方法。</li><li><code>@Bean</code> 注解用于方法上，表示该方法的返回值是一个 Spring Bean，该方法通常用于创建复杂的对象或外部库的实例。</li></ul><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java复制代码@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MyBean myBean() &#123;</span><br><span class="line">        return new MyBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过 XML 配置</strong>（传统方式）：</p><ul><li>在 Spring 的 XML 配置文件中，可以使用 <code>&lt;bean&gt;</code> 元素定义 Spring Bean。</li></ul><p><strong>示例</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="16-spring-factories"><a href="#16-spring-factories" class="headerlink" title="16.spring.factories"></a>16.spring.factories</h3><p><code>spring.factories</code> 文件在 Spring Boot 中的主要作用是进行自动配置，而不是直接声明 Spring Bean。但是，通过在 <code>spring.factories</code> 文件中声明自动配置类（通常带有 <code>@Configuration</code> 注解的类），可以间接地声明和注册 Spring Bean。</p><p><code>spring.factories</code> 文件用于指定一些带有 <code>@Configuration</code> 注解的配置类，这些配置类在 Spring Boot 启动时会被自动加载，并且其中的 <code>@Bean</code> 方法会生成并注册 Spring Bean。</p><p><code>spring.factories</code> 不能完全替代 <code>@ComponentScan</code> 的主要原因在于它们的设计目的和使用场景不同。虽然 <code>spring.factories</code> 文件可以用来声明自动配置类，但它并不能直接扫描和注册所有类型的组件，例如服务类（<code>@Service</code>）、数据访问类（<code>@Repository</code>）、控制器类（<code>@Controller</code>）等。</p><h5 id="主要区别和原因"><a href="#主要区别和原因" class="headerlink" title="主要区别和原因"></a>主要区别和原因</h5><ol><li><strong>用途和设计目的</strong>：<ul><li>**<code>spring.factories</code>**：设计用于声明自动配置类，这些类在 Spring Boot 启动时自动加载。它主要用于框架和库的自动配置，使得用户无需显式配置某些功能。</li><li>**<code>@ComponentScan</code>**：设计用于显式地扫描和注册 Spring 组件，包括服务类、控制器类、数据访问类等。它用于 Spring 应用的配置类或主类中，指定要扫描的包路径。</li></ul></li><li><strong>自动装配的类型</strong>：<ul><li>**<code>spring.factories</code>**：主要用于加载配置类，配置类中的 <code>@Bean</code> 方法定义 Spring Bean。这些配置类通常结合条件注解（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnProperty</code> 等）使用，以控制配置是否生效。</li><li>**<code>@ComponentScan</code>**：用于扫描指定包路径下的所有组件类，自动装配 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等注解标记的类。</li></ul></li><li><strong>条件性配置</strong>：<ul><li>**<code>spring.factories</code>**：自动配置类结合条件注解使用，可以实现条件性配置，根据不同的条件加载或不加载某些配置。</li><li>**<code>@ComponentScan</code>**：用于扫描和注册组件类，无法直接实现条件性配置。</li></ul></li></ol><h3 id="17-自动配置"><a href="#17-自动配置" class="headerlink" title="17.自动配置"></a>17.自动配置</h3><p>在 Spring Boot 中，实现自动配置的主要方式包括使用 <code>spring.factories</code> 文件和各种注解。下面是实现自动配置的总结：</p><h5 id="自动配置的实现方式"><a href="#自动配置的实现方式" class="headerlink" title="自动配置的实现方式"></a>自动配置的实现方式</h5><ol><li><p><strong>使用 <code>spring.factories</code> 文件</strong>：</p><ul><li><code>spring.factories</code> 文件是 Spring Boot 用于自动配置的重要机制。它位于类路径下的 <code>META-INF</code> 目录中。</li><li>通过在 <code>spring.factories</code> 文件中声明自动配置类，Spring Boot 会在启动时加载并应用这些配置类。</li></ul><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">properties复制代码# META-INF/spring.factories</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.example.config.MyAutoConfiguration</span><br></pre></td></tr></table></figure><p><strong>自动配置类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>@Configuration</code> 注解</strong>：</p><ul><li>配置类使用 <code>@Configuration</code> 注解声明，表示这是一个 Spring 配置类。</li><li>配置类可以包含一个或多个 <code>@Bean</code> 方法，用于定义 Spring Bean。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用条件注解</strong>：</p><ul><li>条件注解用于控制配置类或 <code>@Bean</code> 方法的生效条件。</li><li>常用的条件注解包括 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>、<code>@ConditionalOnProperty</code> 等。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;com.example.SomeClass&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionalConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyConditionalBean <span class="title function_">myConditionalBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyConditionalBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>@Component</code> 注解及其派生注解</strong>：</p><ul><li><code>@Component</code> 注解及其派生注解（如 <code>@Service</code>、<code>@Repository</code>、<code>@Controller</code>）用于声明组件类，组件类会被 Spring 容器管理。</li><li>这些组件类会通过组件扫描机制自动注册为 Spring Bean。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="comment">// 服务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>@ComponentScan</code> 注解</strong>：</p><ul><li><code>@ComponentScan</code> 注解用于指定要扫描的包，扫描包下的所有组件类。</li><li>默认情况下，Spring Boot 会扫描启动类所在包及其子包。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>@Import</code> 注解</strong>：</p><ul><li><code>@Import</code> 注解用于导入其他配置类或组件类。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Import(&#123;ConfigA.class, ConfigB.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="自动配置的优点"><a href="#自动配置的优点" class="headerlink" title="自动配置的优点"></a>自动配置的优点</h5><ol><li><strong>简化配置</strong>：通过自动配置，开发者无需手动配置常见的 Spring Bean，大大简化了应用程序的配置工作。</li><li><strong>模块化</strong>：自动配置可以分模块进行，易于维护和管理。</li><li><strong>灵活性</strong>：通过条件注解，自动配置可以根据环境和依赖的不同自动调整，提供了很高的灵活性。</li></ol><h5 id="自动配置的总结"><a href="#自动配置的总结" class="headerlink" title="自动配置的总结"></a>自动配置的总结</h5><p>通过上述机制，Spring Boot 实现了强大的自动配置功能。开发者可以通过 <code>spring.factories</code> 文件声明配置类，也可以通过注解方式直接在代码中实现自动配置。这些配置机制使得 Spring Boot 应用的配置更加简洁、模块化和灵活。</p><p>具体来说，<code>@ComponentScan</code> 注解会扫描指定包下的所有组件类，包括：</p><ul><li>带有 <code>@Component</code> 注解的类</li><li>带有 <code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 注解的类（这些注解都是 <code>@Component</code> 的派生注解）</li><li>带有 <code>@Configuration</code> 注解的配置类</li></ul><h3 id="18-共享配置"><a href="#18-共享配置" class="headerlink" title="18.共享配置"></a>18.共享配置</h3><p>1.引入依赖</p><p>2.写bootstrap.yaml文件，进行nacos基础访问配置与要拉取的配置文件</p><p>3.写application.yaml文件，完成配置文件中变量设置、服务端口号设置、特殊配置（feign配置）。</p><h3 id="19-读取配置类数据"><a href="#19-读取配置类数据" class="headerlink" title="19.读取配置类数据"></a>19.读取配置类数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mail&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigProperties</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String hostName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// standard getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ConfigurationProperties最适用于所有具有相同前缀的分层属性，用于将配置文件中mail开头的属性绑定到POJO中特点和用途：</p><ol><li><strong>属性绑定</strong>：可以将外部配置文件中的属性直接绑定到 Java 对象中。</li><li><strong>类型安全</strong>：通过 POJO（Plain Old Java Object）实现类型安全的配置管理。</li><li><strong>批量配置</strong>：适用于配置项较多的情况，通过前缀可以批量读取配置项。</li><li>**结合 <code>@EnableConfigurationProperties</code>**：通常与 <code>@EnableConfigurationProperties</code> 注解结合使用，来启用对 <code>@ConfigurationProperties</code> 的支持。</li></ol><p>使用 <code>@ConfigurationProperties + @Configuration</code> 时，该类不仅可以绑定配置属性，还可以作为 Spring 配置类定义其他 Spring Bean。</p><p>使用 <code>@ConfigurationProperties + @Component</code> 时，该类主要用于属性绑定，被 Spring 识别为一个普通组件，而不是配置类。</p><h3 id="20-Data"><a href="#20-Data" class="headerlink" title="20.@Data"></a>20.@Data</h3><p>@Data ： 注在类上，提供类的get、set、equals、hashCode、canEqual、toString方法</p><h3 id="21-Configuration-相对于-Component"><a href="#21-Configuration-相对于-Component" class="headerlink" title="21.@Configuration 相对于 @Component"></a>21.<code>@Configuration</code> 相对于 <code>@Component</code></h3><p><code>@Configuration</code> 相对于 <code>@Component</code> 所多的功能和优势：</p><ol><li><p><strong>显式定义 Bean</strong>：</p><ul><li><p><code>@Configuration</code>：允许通过 @Bean 方法显式地定义和配置 Spring Bean。每个 @Bean 方法的返回值会被 Spring 容器管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>**<code>@Component</code>**：没有提供显式定义 Bean 的机制，类本身只是作为一个组件被 Spring 容器管理。</p></li></ul></li><li><p><strong>Bean 配置和依赖注入</strong>：</p><ul><li><p><code>@Configuration</code>：可以在配置类中定义多个 @Bean 方法，Bean 方法之间可以通过方法调用实现依赖注入，提供高度灵活的 Bean 配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyController <span class="title function_">myController</span><span class="params">(MyService myService)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyController</span>(myService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>**<code>@Component</code>**：只能通过字段注入、构造器注入或 setter 注入来注入依赖，无法在类内部以方法调用的形式注入依赖。</p></li></ul></li><li><p><strong>配置类的代理增强</strong>：</p><ul><li><p><code>@Configuration</code>：Spring 容器会为 @Configuration 类生成一个代理类，以确保 @Bean 方法的调用是通过 Spring 容器的，这样可以保证每个 Bean 是单例的，即使 @Bean 方法被多次调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyService <span class="title function_">myService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AnotherService <span class="title function_">anotherService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 即使这里调用 myService() 方法，也会返回同一个 MyService 实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnotherService</span>(myService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>**<code>@Component</code>**：没有这种机制，因此如果在一个组件内部调用创建其他 Bean 的方法，每次调用都会返回一个新的实例，而不是单例。</p></li></ul></li><li><p><strong>用途和职责</strong>：</p><ul><li>**<code>@Configuration</code>**：主要用于配置和管理 Spring Bean，适合复杂的配置场景和 Bean 管理。</li><li>**<code>@Component</code>**：用于标记一个普通的 Spring Bean，适合简单的组件定义，不涉及复杂配置。</li></ul></li></ol><h4 id="选择指南"><a href="#选择指南" class="headerlink" title="选择指南"></a>选择指南</h4><ul><li>使用 <code>@Component</code>：<ul><li>适用于定义简单的 Spring 管理的组件。</li><li>适合不需要复杂配置的 Bean。</li><li>常用于服务层、持久层和控制器层的组件，使用 <code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等特化注解。</li></ul></li><li>使用 <code>@Configuration</code>：<ul><li>适用于需要复杂配置的场景。</li><li>适合定义多个互相依赖的 Bean，提供细粒度的控制。</li><li>常用于配置数据源、事务管理、MVC 设置等需要详细配置的场景。</li></ul></li></ul><h3 id="22-bootstrap：和nacos建立连接。"><a href="#22-bootstrap：和nacos建立连接。" class="headerlink" title="22.bootstrap：和nacos建立连接。"></a>22.bootstrap：和nacos建立连接。</h3><h3 id="23-解决服务雪崩："><a href="#23-解决服务雪崩：" class="headerlink" title="23.解决服务雪崩："></a>23.解决服务雪崩：</h3><p>1.保护服务提供者</p><p>​限流，限制在可以处理的范围内</p><p>2.服务调用者做好隔离</p><p>​线程隔离，控制业务可以用的线程数量，将故障隔离在一定范围，避免服务者资源耗尽。</p><p>​熔断，当异常比例过高时，拒绝所有请求，直接走fallback。失败处理：定义fallback逻辑，业务失败时不再抛异常，而是返回默认数据或友好数据</p><h3 id="24-sentinel使用"><a href="#24-sentinel使用" class="headerlink" title="24.sentinel使用"></a>24.sentinel使用</h3><p>1.在cmd以8090端口启用</p><p>2.pom引入依赖</p><p>3.application中设置sentinel地址</p><p>4.访问localhost:8090来访问控制台</p><p>5.设置sentinel以访问方式+路径为资源名称</p><p>线程隔离：线程可用资源的控制。</p><p>并发线程数：可以使用的资源</p><p>​</p><h3 id="25-Feign的Fallback"><a href="#25-Feign的Fallback" class="headerlink" title="25.Feign的Fallback"></a>25.Feign的Fallback</h3><p>商品微服务出问题时，隔离查商品的远程调用，这样整个购物车服务没问题</p><p>采用设置Feign的Fallback，可以在商品查询服务失败时，通过Sentinel及时隔离故障，从而防止由商品模块引起的购物车模块异常。这样，购物车查询功能仍能正常返回其他有效信息(购买物品的图片，名字等信息)，只是商品价格信息为空，提高了系统的稳定性和用户体验。通过这种方式，可以实现更细粒度的故障处理和更高的业务连续性。</p><p>实现fallback步骤：</p><p>1，开启feign的sentinel监控，从而在sentinel中监控到feign客户端，并能实现流控</p><p>2，通过FallbackFactory配置feign的fallback</p><p>①实现FallbackFactory接口</p><p>②重写create方法，return一个备用方案</p><p>3，将2中写的FallbackFactory由@Bean注册到spring容器中</p><p>4，在对应的feign客户端中配置fallbackfactory信息</p><p>如此便完成了备用方案的设置。开启限流或熔断后便可以使用了。</p><h3 id="26-限流与熔断"><a href="#26-限流与熔断" class="headerlink" title="26.限流与熔断"></a>26.限流与熔断</h3><p>限流的意义在于防止因某服务的故障而占用过多线程，进而影响别人</p><p>而熔断意义在于某服务故障时，熔断，从而防止因某服务故障而导致的耽误时间，减少资源浪费，大大提升响应速度</p><h3 id="27-分布式事务"><a href="#27-分布式事务" class="headerlink" title="27.分布式事务"></a>27.分布式事务</h3><p>1，事务协调者独立，要搭建事务协调者</p><p>2，tm，rm要和tc交互，引入seata依赖，配置到tc的连接。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mainpage</title>
    <link href="/2024/06/20/mainpage/"/>
    <url>/2024/06/20/mainpage/</url>
    
    <content type="html"><![CDATA[<p>123</p><p>213</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/06/20/hello-world/"/>
    <url>/2024/06/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
