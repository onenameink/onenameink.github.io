[{"title":"ceshi","url":"/2024/06/20/ceshi/","content":"1231123\n"},{"title":"mainpage","url":"/2024/06/20/mainpage/","content":"123\n213\n"},{"title":"Hello World","url":"/2024/06/20/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"ceshi","url":"/2024/06/20/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0/","content":"1. @ComponentScan@ComponentScan(basePackages = &#123;&quot;com.shangan&quot;&#125;)\n\n含义@ComponentScan 注解用于指定 Spring 应用程序上下文在初始化时应该扫描的包，以查找和注册 Spring 组件（如 @Component、@Service、@Repository、@Controller 等注解标记的类）。\n作用\n包扫描：扫描 com.shangan 包及其子包中的所有类，寻找标记了 Spring 组件注解的类，并将它们注册到 Spring 应用上下文中。\n自动装配：通过自动装配（Autowiring）机制，可以在应用程序的其他部分（如 Service 层、Controller 层等）中自动注入这些组件。\n\n2. @MapperScan@MapperScan(&#123;&quot;com.shangan.trade.coupon.db.mappers&quot;&#125;)\n\n含义@MapperScan 注解用于指定 MyBatis 应该扫描的包，以查找和注册 MyBatis 的 Mapper 接口。\n作用\nMapper 扫描：扫描 com.shangan.trade.coupon.db.mappers 包及其子包中的所有接口，寻找标记了 @Mapper 注解的接口，并将它们注册为 MyBatis Mapper。\n生成代理对象：MyBatis 会为这些 Mapper 接口生成代理对象，这些对象可以直接在应用程序中调用，以执行数据库操作。\n\n@MapperScan 识别和注入的机制\n启动时扫描：Spring Boot 启动时，@MapperScan 会触发包扫描机制，扫描指定包路径下的所有接口。\n符合条件的接口：这些接口如果符合 MyBatis Mapper 的规范（即符合方法签名），就会被认为是 Mapper 接口。\n生成代理对象：MyBatis 会为这些接口生成代理对象，这些代理对象会被注册为 Spring Bean。\n自动注入：Spring 会将这些代理对象作为 Spring Bean 注入到需要使用它们的地方（例如 Service 类中）。\n\n即使没有使用 @Mapper 注解，只要你使用了 @MapperScan 注解并指定了正确的包路径，MyBatis 仍然能够识别这些接口为 Mapper 接口，并将它们注册为 Spring Bean。这是因为 @MapperScan 注解本质上是通过包扫描机制和 MyBatis 的内部实现来完成这一任务的。\n通过这种方式，你可以简化配置，并确保所有符合条件的 Mapper 接口都能被自动扫描和注入到 Spring 容器中。\n3.MyBatis逆向开发工具生成mapper4.threadlocal\n每个线程有一个独立的 ThreadLocalMap。\n需要存储不同类型的值时，就创建不同的 ThreadLocal 实例（每个实例代表一个不同的键）。\n这些 ThreadLocal 实例不直接存储数据，而是作为键存在于 ThreadLocalMap 中，每个键对应一个值的存储位置。\n通过 ThreadLocal 实例访问数据时，实际上是在操作 ThreadLocalMap 中对应的条目。\n\n这种机制确保了每个线程的数据隔离，即使多个线程使用相同的 ThreadLocal 类型，它们也不会共享数据，因为每个线程都有自己的 ThreadLocalMap 实例。\n5@AllArgsConstructor给所有参数都加上构造函数\n@RequiredArgsConstructor&#x2F;&#x2F;对必须的成员变量初始化，给加final的成员变量生成构造函数。初始化过的也不会被初始化\n6.远程调用discoveryclient拉取实例列表；\n进行负载均衡，选取实例；\n得到uri；\nrestTemplate来发送http请求，获得其他服务查询后的指定结果。\nOpenFeign：\n加依赖（OpenFeign和loadBalancer的）；启动类注解@EnableFeignClients；新建Client接口来声明查询的函数。\n在接口中（接口不用实现，由openfeign自动实现）\n@FeignClient(&quot;item-service&quot;)//声明服务名称public interface ItemClient &#123;    @GetMapping(&quot;/items&quot;)//借用mvc注解，表面这是http的get请求。    //请求路径：/items    List&lt;ItemDTO&gt; queryItemByIds(@RequestParam(&quot;ids&quot;) Collection&lt;Long&gt; ids);    //List&lt;ItemDTO&gt;声明返回参数，openfeign会将收到的json转为该格式    //@RequestParam(&quot;ids&quot;)声明请求参数，即路径中有ids    //Collection&lt;Long&gt; ids传入的数据&#125;\n\n这样OpenFeign便替代原来discoveryclient和restTemplate的作用，来首先向注册中心请求实例列表，然后负载均衡选择实例，然后发送http请求，然后将收到信息转化为对应形式，这样便完成了微服务之间数据的调用。\n实际使用只需注入ItemClient，然后使用queryItemByIds即可\nList&lt;ItemDTO&gt; items = itemClient.queryItemByIds(itemIds);\n\n连接池减少创建连接销毁连接带来的损耗。\n默认feign发http请求不带连接池，所以可以换成okhttp来提升响应速度。\n最佳实践新建一个api模块，存放所有模块要暴露的接口。\n这样别的模块依赖ta便具有了这些接口。\n注意：启动类上要加@EnableFeignClients(basePackages &#x3D; “com.hmall.api.client”)\n指定扫描包去扫描feign客户端，这样才可以扫描到，才能去使用\njwt的库要加进去\nnacos要打开\n运行要选择local sql\n7.网关的登录校验思路\nhandlemapping实现是基于路由断言来做匹配的，基于配置的断言与前端请求匹配，找到合适的路由，然后存入上下文\n1.如何在网关自定义过滤器并控制顺序；2.如何在网关中进行登录校验3.如何把网关的用户信息传递给微服务（使用网关api进行）4.如何在微服务之间传递用户信息（使用feign进行）\n网关中有很多过滤器（默认的与需配置的），过滤器生效与不生效是不一定的，filteringwebhandler作用在于找到生效的过滤器，进行排序，并依次执行\nfilteringwebhandler最后是nettyroutingfilter，这个过滤器是最后的过滤器，其把请求转到微服务中，当返回结果时，会封装结果，存入上下文，依次返回给其他过滤器。\n过滤器内部有pre和post两个部分，请求会先执行过滤器中的pre部分，若失败，则直接结束，请求也不会被转发，只有pre逻辑执行成功情况下，才会调用执行下一个pre逻辑，依次向下执行，\n因此要通过网关实现登录校验，需要自定义过滤器实现校验逻辑，并且需要在nettyroutingfilter之前的pre部分进行，这样才可以在校验失败时，报错。从而不会转发。\n如何把网关得到的用户信息传递给微服务：由于使用http发，因此可以在请求头中写用户信息来传递。传统的threadlocal不可以，因为是微服务，单个服务用一个tomcat服务器，threadlocal只能在tomcat内部的线程之间共享，因此无法使用threadlocal来共享。\n8.ConfigurationProperties注解报错@ConfigurationProperties\n\nNot registered via @EnableConfigurationProperties, marked as Spring component, or scanned via @ConfigurationPropertiesScan\n9.nginx使用nginx，因此前端都是通过18080端口访问nginx服务器，这样来访问网关以及服务。\n10.gateway与mvc网关用的不是springmvc的架构，他是非阻塞的结构，因此无法用mvc里的元素\n11.匿名内部类使用匿名内部类可以有效地实现两步：\n1.创建一个类，该类继承或实现接口\n2.创建一个对象\n&#x3D;&#x3D;因此在希望使用一个类，但只希望使用其创建一次对象时，就可以使用匿名内部类&#x3D;&#x3D;\n12.FeignFeign在编写http请求时，要与controller完全一致\n13.微服务中登录验证与信息传递的拦截器登录验证：\n网关中过滤器实现。校验token，得到用户信息。有效才路由，无效则返回。\n信息传递：\n1）网关到微服务：\n过滤器将用户信息保存到请求头，然后发送至微服务，微服务使用mvc拦截器获取用户信息，并存入threadlocal（微服务均在一个线程上，因此可以用threadlocal存储）来方便调用。\n2）微服务间远程调用：\n微服务的远程调用也需要用户信息，即被调用的程序执行操作需要进一步的用户信息，由于用户信息经由拦截器存储，因此需要在使用openfeign发送http请求时在请求头中加入用户信息。\n加入用户信息可以采用feign的拦截器，其会在每次feign调用时都处理，因此可以在其中加入填写请求头的操作。\ntips：\n1）mvc拦截器在common中写，因此所有都会继承，但网关使用的不是mvc架构，因此会报错。这就需要\n@ConditionalOnClass(DispatcherServlet.class)来判断该模块是否为微服务，是的话才会加载mvc配置类，才会加入拦截器。\n2）拦截器有pre和after部分，pre是存用户信息，after是删除。需注意pre要先判断用户信息是否为空（用户登陆时不会拦截，因此用户信息可能为空，拦截器也需要考虑这种情况）。\n3）mvc配置类写完后，还需要自动注入\nSpring Boot 的自动配置机制是会扫描所有父类的spring.factories，然后加载里面的所有配置类\n\n微服务内部同一个线程来回调，所以保存到threadlocal来保存用户信息。\n微服务调用spring mvc拦截器来拦截请求。\nfeign拦截器会在每一次请求时生效。\n采用匿名内部类生成拦截器对象更方便，不用重新写一个类+生成对象了。\n14.javaBean在 Java 编程中，”Java Bean” 是一个具有特定特征的 Java 对象。虽然所有 Java Bean 都是 Java 对象，但并不是所有 Java 对象都是 Java Bean。Java Bean 遵循一些特定的约定，使其在许多框架（如 Spring）中易于使用。\nJava Bean 的特征\n私有属性（Private Fields）：\nJava Bean 使用私有字段来存储其属性。\n\n\n公有的无参构造函数（Public No-Arg Constructor）：\nJava Bean 必须有一个公有的无参构造函数。这允许框架和工具通过反射机制创建 Bean 实例。\n\n\nGetter 和 Setter 方法：\nJava Bean 提供公有的 getter 和 setter 方法用于访问和修改属性。getter 和 setter 方法遵循命名约定：getXxx 和 setXxx（对于布尔类型的属性，getter 方法可以使用 isXxx）。\n\n\n\n15.什么是 Spring Bean\n定义：Spring Bean 是由 Spring 容器管理的对象。Spring 容器负责生命周期管理、依赖注入以及与 Spring 上下文的交互。\n注册方式：Spring Bean 可以通过多种方式注册到 Spring 容器中，包括注解和 XML 配置。\n作用：Spring Bean 可以用于任何需要被 Spring 容器管理的对象，包括服务、数据访问对象、控制器、配置类等。\n\n声明 Spring Bean 的方式\n使用 @Component 注解：\n\n@Component 注解是一个通用的注解，表示一个组件类。它是一个元注解，可以用于标记任何要作为 Spring Bean 管理的类。\n\n派生注解\n：\n@Component\n\n 还有几个特定用途的派生注解：\n\n@Service：表示服务层组件。\n@Repository：表示数据访问层组件，具有数据访问层的特定功能，如异常转换。\n@Controller：表示 Spring MVC 控制器。\n\n\n\n示例：\njava复制代码@Componentpublic class MyComponent &#123;    // 组件逻辑&#125;@Servicepublic class MyService &#123;    // 服务逻辑&#125;@Repositorypublic class MyRepository &#123;    // 数据访问逻辑&#125;@Controllerpublic class MyController &#123;    // 控制器逻辑&#125;\n\n使用 @Configuration 和 @Bean 注解：\n\n@Configuration 注解表示一个配置类，该类可以包含一个或多个 @Bean 方法。\n@Bean 注解用于方法上，表示该方法的返回值是一个 Spring Bean，该方法通常用于创建复杂的对象或外部库的实例。\n\n示例：\njava复制代码@Configurationpublic class AppConfig &#123;    @Bean    public MyBean myBean() &#123;        return new MyBean();    &#125;&#125;\n\n通过 XML 配置（传统方式）：\n\n在 Spring 的 XML 配置文件中，可以使用 &lt;bean&gt; 元素定义 Spring Bean。\n\n示例：\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot;/&gt;&lt;/beans&gt;\n\n16.spring.factoriesspring.factories 文件在 Spring Boot 中的主要作用是进行自动配置，而不是直接声明 Spring Bean。但是，通过在 spring.factories 文件中声明自动配置类（通常带有 @Configuration 注解的类），可以间接地声明和注册 Spring Bean。\nspring.factories 文件用于指定一些带有 @Configuration 注解的配置类，这些配置类在 Spring Boot 启动时会被自动加载，并且其中的 @Bean 方法会生成并注册 Spring Bean。\nspring.factories 不能完全替代 @ComponentScan 的主要原因在于它们的设计目的和使用场景不同。虽然 spring.factories 文件可以用来声明自动配置类，但它并不能直接扫描和注册所有类型的组件，例如服务类（@Service）、数据访问类（@Repository）、控制器类（@Controller）等。\n主要区别和原因\n用途和设计目的：\n**spring.factories**：设计用于声明自动配置类，这些类在 Spring Boot 启动时自动加载。它主要用于框架和库的自动配置，使得用户无需显式配置某些功能。\n**@ComponentScan**：设计用于显式地扫描和注册 Spring 组件，包括服务类、控制器类、数据访问类等。它用于 Spring 应用的配置类或主类中，指定要扫描的包路径。\n\n\n自动装配的类型：\n**spring.factories**：主要用于加载配置类，配置类中的 @Bean 方法定义 Spring Bean。这些配置类通常结合条件注解（如 @ConditionalOnClass、@ConditionalOnProperty 等）使用，以控制配置是否生效。\n**@ComponentScan**：用于扫描指定包路径下的所有组件类，自动装配 @Component、@Service、@Repository、@Controller 等注解标记的类。\n\n\n条件性配置：\n**spring.factories**：自动配置类结合条件注解使用，可以实现条件性配置，根据不同的条件加载或不加载某些配置。\n**@ComponentScan**：用于扫描和注册组件类，无法直接实现条件性配置。\n\n\n\n17.自动配置在 Spring Boot 中，实现自动配置的主要方式包括使用 spring.factories 文件和各种注解。下面是实现自动配置的总结：\n自动配置的实现方式\n使用 spring.factories 文件：\n\nspring.factories 文件是 Spring Boot 用于自动配置的重要机制。它位于类路径下的 META-INF 目录中。\n通过在 spring.factories 文件中声明自动配置类，Spring Boot 会在启动时加载并应用这些配置类。\n\n示例：\nproperties复制代码# META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.example.config.MyAutoConfiguration\n\n自动配置类：\npackage com.example.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MyAutoConfiguration &#123;    @Bean    public MyService myService() &#123;        return new MyService();    &#125;&#125;\n\n使用 @Configuration 注解：\n\n配置类使用 @Configuration 注解声明，表示这是一个 Spring 配置类。\n配置类可以包含一个或多个 @Bean 方法，用于定义 Spring Bean。\n\n示例：\n@Configurationpublic class AppConfig &#123;    @Bean    public MyBean myBean() &#123;        return new MyBean();    &#125;&#125;\n\n使用条件注解：\n\n条件注解用于控制配置类或 @Bean 方法的生效条件。\n常用的条件注解包括 @ConditionalOnClass、@ConditionalOnMissingBean、@ConditionalOnProperty 等。\n\n示例：\n@Configuration@ConditionalOnClass(name = &quot;com.example.SomeClass&quot;)public class ConditionalConfig &#123;    @Bean    public MyConditionalBean myConditionalBean() &#123;        return new MyConditionalBean();    &#125;&#125;\n\n使用 @Component 注解及其派生注解：\n\n@Component 注解及其派生注解（如 @Service、@Repository、@Controller）用于声明组件类，组件类会被 Spring 容器管理。\n这些组件类会通过组件扫描机制自动注册为 Spring Bean。\n\n示例：\n@Servicepublic class MyService &#123;    // 服务逻辑&#125;\n\n使用 @ComponentScan 注解：\n\n@ComponentScan 注解用于指定要扫描的包，扫描包下的所有组件类。\n默认情况下，Spring Boot 会扫描启动类所在包及其子包。\n\n示例：\n@SpringBootApplication@ComponentScan(basePackages = &quot;com.example&quot;)public class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\n\n使用 @Import 注解：\n\n@Import 注解用于导入其他配置类或组件类。\n\n示例：\n@SpringBootApplication@Import(&#123;ConfigA.class, ConfigB.class&#125;)public class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\n\n自动配置的优点\n简化配置：通过自动配置，开发者无需手动配置常见的 Spring Bean，大大简化了应用程序的配置工作。\n模块化：自动配置可以分模块进行，易于维护和管理。\n灵活性：通过条件注解，自动配置可以根据环境和依赖的不同自动调整，提供了很高的灵活性。\n\n自动配置的总结通过上述机制，Spring Boot 实现了强大的自动配置功能。开发者可以通过 spring.factories 文件声明配置类，也可以通过注解方式直接在代码中实现自动配置。这些配置机制使得 Spring Boot 应用的配置更加简洁、模块化和灵活。\n具体来说，@ComponentScan 注解会扫描指定包下的所有组件类，包括：\n\n带有 @Component 注解的类\n带有 @Service、@Repository、@Controller 注解的类（这些注解都是 @Component 的派生注解）\n带有 @Configuration 注解的配置类\n\n18.共享配置1.引入依赖\n2.写bootstrap.yaml文件，进行nacos基础访问配置与要拉取的配置文件\n3.写application.yaml文件，完成配置文件中变量设置、服务端口号设置、特殊配置（feign配置）。\n19.读取配置类数据@Configuration@ConfigurationProperties(prefix = &quot;mail&quot;)public class ConfigProperties &#123;        private String hostName;    private int port;    private String from;     // standard getters and setters&#125;\n\n@ConfigurationProperties最适用于所有具有相同前缀的分层属性，用于将配置文件中mail开头的属性绑定到POJO中特点和用途：\n\n属性绑定：可以将外部配置文件中的属性直接绑定到 Java 对象中。\n类型安全：通过 POJO（Plain Old Java Object）实现类型安全的配置管理。\n批量配置：适用于配置项较多的情况，通过前缀可以批量读取配置项。\n**结合 @EnableConfigurationProperties**：通常与 @EnableConfigurationProperties 注解结合使用，来启用对 @ConfigurationProperties 的支持。\n\n使用 @ConfigurationProperties + @Configuration 时，该类不仅可以绑定配置属性，还可以作为 Spring 配置类定义其他 Spring Bean。\n使用 @ConfigurationProperties + @Component 时，该类主要用于属性绑定，被 Spring 识别为一个普通组件，而不是配置类。\n20.@Data@Data ： 注在类上，提供类的get、set、equals、hashCode、canEqual、toString方法\n21.@Configuration 相对于 @Component@Configuration 相对于 @Component 所多的功能和优势：\n\n显式定义 Bean：\n\n@Configuration：允许通过 @Bean 方法显式地定义和配置 Spring Bean。每个 @Bean 方法的返回值会被 Spring 容器管理。\n@Configurationpublic class AppConfig &#123;    @Bean    public MyService myService() &#123;        return new MyServiceImpl();    &#125;&#125;\n\n**@Component**：没有提供显式定义 Bean 的机制，类本身只是作为一个组件被 Spring 容器管理。\n\n\n\nBean 配置和依赖注入：\n\n@Configuration：可以在配置类中定义多个 @Bean 方法，Bean 方法之间可以通过方法调用实现依赖注入，提供高度灵活的 Bean 配置。\n@Configurationpublic class AppConfig &#123;    @Bean    public MyService myService() &#123;        return new MyServiceImpl();    &#125;    @Bean    public MyController myController(MyService myService) &#123;        return new MyController(myService);    &#125;&#125;\n\n**@Component**：只能通过字段注入、构造器注入或 setter 注入来注入依赖，无法在类内部以方法调用的形式注入依赖。\n\n\n\n配置类的代理增强：\n\n@Configuration：Spring 容器会为 @Configuration 类生成一个代理类，以确保 @Bean 方法的调用是通过 Spring 容器的，这样可以保证每个 Bean 是单例的，即使 @Bean 方法被多次调用。\n@Configurationpublic class AppConfig &#123;    @Bean    public MyService myService() &#123;        return new MyServiceImpl();    &#125;    @Bean    public AnotherService anotherService() &#123;        // 即使这里调用 myService() 方法，也会返回同一个 MyService 实例        return new AnotherService(myService());    &#125;&#125;\n\n**@Component**：没有这种机制，因此如果在一个组件内部调用创建其他 Bean 的方法，每次调用都会返回一个新的实例，而不是单例。\n\n\n\n用途和职责：\n\n**@Configuration**：主要用于配置和管理 Spring Bean，适合复杂的配置场景和 Bean 管理。\n**@Component**：用于标记一个普通的 Spring Bean，适合简单的组件定义，不涉及复杂配置。\n\n\n\n选择指南\n使用 @Component：\n适用于定义简单的 Spring 管理的组件。\n适合不需要复杂配置的 Bean。\n常用于服务层、持久层和控制器层的组件，使用 @Service、@Repository、@Controller 等特化注解。\n\n\n使用 @Configuration：\n适用于需要复杂配置的场景。\n适合定义多个互相依赖的 Bean，提供细粒度的控制。\n常用于配置数据源、事务管理、MVC 设置等需要详细配置的场景。\n\n\n\n22.bootstrap：和nacos建立连接。23.解决服务雪崩：1.保护服务提供者\n​\t限流，限制在可以处理的范围内\n2.服务调用者做好隔离\n​\t线程隔离，控制业务可以用的线程数量，将故障隔离在一定范围，避免服务者资源耗尽。\n​\t熔断，当异常比例过高时，拒绝所有请求，直接走fallback。失败处理：定义fallback逻辑，业务失败时不再抛异常，而是返回默认数据或友好数据\n24.sentinel使用1.在cmd以8090端口启用\n2.pom引入依赖\n3.application中设置sentinel地址\n4.访问localhost:8090来访问控制台\n5.设置sentinel以访问方式+路径为资源名称\n线程隔离：线程可用资源的控制。\n并发线程数：可以使用的资源\n​\t\n25.Feign的Fallback商品微服务出问题时，隔离查商品的远程调用，这样整个购物车服务没问题\n采用设置Feign的Fallback，可以在商品查询服务失败时，通过Sentinel及时隔离故障，从而防止由商品模块引起的购物车模块异常。这样，购物车查询功能仍能正常返回其他有效信息(购买物品的图片，名字等信息)，只是商品价格信息为空，提高了系统的稳定性和用户体验。通过这种方式，可以实现更细粒度的故障处理和更高的业务连续性。\n实现fallback步骤：\n1，开启feign的sentinel监控，从而在sentinel中监控到feign客户端，并能实现流控\n2，通过FallbackFactory配置feign的fallback\n①实现FallbackFactory接口\n②重写create方法，return一个备用方案\n3，将2中写的FallbackFactory由@Bean注册到spring容器中\n4，在对应的feign客户端中配置fallbackfactory信息\n如此便完成了备用方案的设置。开启限流或熔断后便可以使用了。\n26.限流与熔断限流的意义在于防止因某服务的故障而占用过多线程，进而影响别人\n而熔断意义在于某服务故障时，熔断，从而防止因某服务故障而导致的耽误时间，减少资源浪费，大大提升响应速度\n27.分布式事务1，事务协调者独立，要搭建事务协调者\n2，tm，rm要和tc交互，引入seata依赖，配置到tc的连接。\n"}]